<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[XMLHttpRequest.send()函数]]></title>
    <url>%2F2019%2F07%2F29%2FrequestSend%2F</url>
    <content type="text"><![CDATA[request.send(null)今天遇到了Ajax请求当中的request.send(null)。但是不知道这句话由什么用处。所以上网搜了以下。 我遇到的例子是这样的： 1234567891011121314151617181920function getNewContent() &#123; var request = getHTTPObject(); if(request)&#123; request.open(&quot;GET&quot;,&quot;example.txt&quot;,true); request.onreadyStateChange = function() &#123; if(request.readyState == 4)&#123; alert(&quot;Response Received&quot;); var para = document.createElement(&quot;p&quot;); var txt = document.createTextNode(request.responseText); para.appendChild(txt); document.getElementById(&quot;new&quot;).appendChild(para); &#125; &#125; ; request.send(null); &#125; else&#123; alert(&quot;Sorry, your browser doesn&apos;t support XMLHttpRequest&quot;); &#125; alert(&quot;Function Done&quot;);&#125;addLoadEvent(getNewContent); 百度了一下 这个请求分为两种：POST请求和GET请求。 如果是GET请求，就像例子里一样，不用在send()函数里面加内容，放个null就好。因为是在url里面传参数的，如下例子所示： e.g. 12xmlhttp.open(&quot;GET&quot;,&quot;testServlet?name=&quot;+userName,true);xmlhttp.send(null); 如果是POST请求，是要加内容的。因为POST请求不是在url里面传参数的。 e.g. 12345xmlhttp.open(&quot;POST&quot;,&quot;testServlet&quot;,true);//POST方式需要自己设置http的请求头xmlhttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);//POST方式发送数据xmlhttp.send(&quot;name=&quot;+userName); Fighting！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[同源策略和跨域(上)]]></title>
    <url>%2F2019%2F07%2F29%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[今天看《JavaScript DOM编程艺术》这本书的时候，看到了一个新的概念：同源策略。书上说： 在使用Ajax时，千万要注意同源策略。使用XMLHttpRequest对象发送的请求只能访问与其所在的HTML处于同一个域中的数据，不能向其他域发送请求。 这段话看得我一阵懵。啥是同源策略？啥是同一个域？啥是其他域？ 依旧是不同就去百度。 同源是什么？同源是指域名，协议，端口相同。 1.域名: 都属于 www.xxx.com 2.协议:要么都是http，要么都是https 3.端口：端口号要相同。如:80和:8080就不是同一个端口 什么是同源策略？这是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能读写对方资源。所以a.com的下的js脚本采用ajax读写b.com中的文件数据是会报错的。为了保护本地数据不被js返回回来的数据污染，浏览器会拦截客户端发出的请求回来的数据接收。即便请求发送了，服务器响应了，但是不会被浏览器接收！！ 如果没有同源策略，那么就会发生CSRF攻击(来源:陈曦明的博客)。这里讲的很清楚！！！简洁地来说就是利用你登录网站保存下来的cookie来向你登录过的网站发送非法请求。 ==注意==：这里的话，表单提交和链接什么的是不会受到同源策略的影响的，这些不是http请求！！！ 那我就很疑惑了，平常我们写的网页呀什么的不都是往各种网站上去请求API的吗？这个要是被限制住了怎么办？ 同源策略下的正确接口请求1.JSONP2.空iframe加form3.CORS4.代理网上都有解释，但是我现在基础还不够，等到学完js和一些后端语言之后再回来再看可能收获更大！那就先完成这个内容的上篇，以后再回来完成下篇！ Fighting！！！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端页面由哪三层构成？]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%94%B1%E5%93%AA%E4%B8%89%E5%B1%82%E6%9E%84%E6%88%90%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[今天看书的时候，看到了一句话： 网页的行为层(JavaScript)是作用于其结构层(HTML)之上的，还是两种代码混杂在一起？ 这句话貌似没有看起来这么简单，难道行为层就是JavaScript，结构层就是HTML？ 老规矩，百度。 最准确的网页设计思路是把网页分成三个层次，即：结构层、表示层、行为层。 网页的结构层（structural layer）由HTML或XHTML之类的语言负责创建，标签对网页内容的语义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。 网页的结构层（presentation layer）由CSS负责创建，负责了如何显示有关信息的问题。 网页的行为层（behavior layer）由JavaScript和DOM负责，负责了内容该如何对事件做出反应 easy！]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单页面应用（SPA）和多页面应用 （MPA）]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是单页面应用(SinglePage Application)?概念:只有一张Web页面的应用。第一次进入页面时会有一次html请求，公共页面加载一次；切换到其他组件时，路径也相应变化，但是并没有新的html请求。url变化时，js动态地将页面的内容清除，然后将另外一个页面的内容挂载到当前页面上。这时，路由由前端来做，而不是由后端来实现。 优点： 页面跳转用js渲染技术，页面切换快。 缺点: 首屏加载时间慢，SEO差。 什么是多页面应用(MultiPage Application)？概念:由多个完整页面构成，页面之间的跳转是从一个页面跳转到另一个页面。每次跳转都有一个新的http请求，页面切换较慢。 优点: 利于SEO，因为页面所有的内容都放在html中，利于爬虫抓取。 首屏时间快，因为只有一个http请求，没有其他js渲染 缺点: 页面切换较慢，用户体验较差 SPA和MPA的比较||多页面应用MPA|单页面应用SPA| 多页面应用模式 单页面应用模式 应用构成 由多个完整页面构成 一个外壳页面和多个页面片段构成 跳转方式 页面之间的跳转是从一个页面到另一个页面 一个页面片段删除或隐藏，加载另一个页面片段并显示。片段间的模拟跳转，没有开壳页面 跳转后公共资源是否重新加载 是 否 URL模式 http://xxx/page1.html和http://xxx/page2.html http://xxx/shell.html#page1和http://xxx/shell.html#page2 用户体验 页面间切换加载慢，不流畅，用户体验差，尤其在移动端 页面片段间切换快，用户体验好，包括移动设备 能否实现转场动画 否 容易实现（手机APP动效） 页面间传递数据 依赖URL、cookie或者localstorage，实现麻烦 页面传递数据容易（Vuex或Vue中的父子组件通讯props对象） 搜索引擎优化（SEO） 可以直接做 需要单独方案（SSR） 特别适用的范围 需要对搜索引擎友好的网站 对体验要求高，特别是移动应用 开发难度 较低，框架选择容易 较高，需要专门的框架来降低这种模式的开发难度 表格来源：洛卿九的简书]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[什么是正向代理，反向代理和负载均衡？]]></title>
    <url>%2F2019%2F07%2F25%2F%E6%AD%A3%E5%8F%8D%E4%BB%A3%E7%90%86%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[以前没有接触过Nginx，今天偶然看到这个新名词，不自觉就去百度了一下。 什么是Nginx? nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个电子邮件(IMAP、POP3、SMTP)代理服务器；nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡的实现。 (摘自Sugar执着的博客) 解释Nginx的时候貌似又出现了新名词: 电子邮件(IMAP,POP3,SMTP)代理服务器。这个又是什么呢？ IMAP,POP3,SMTP是什么？区别？POP3 POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。(与IMAP有什么区别？) SMTP SMTP 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP协议的发送邮件服务器。 SMTP认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。 增加 SMTP认证的目的是为了使用户避免受到垃圾邮件的侵扰。 IMAP IMAP全称是Internet Mail Access Protocol，即交互式邮件存取协议，它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。 (摘自: 163网易免费邮) 总而言之，这三个东西都是邮件发送或者接收的协议。 正向代理是什么？如今，我们要访问国外的某些网站，正常情况下无法访问，有很多人会用FQ操作去访问。FQ方式就是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，然后由代理服务器去访问国外的网站，然后将访问到的数据发送给我们。 这就是正向代理。一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定了目标。然后代理向原始服务器转交请求，并将获得的内容返回给客户端。 反向代理是什么？反向代理是代理服务器的一种，代理服务器根据根据客户端的请求，从其关联的一组或多组后端服务器获取资源，然后再将这些资源返回给客户端。客户端只会知道代理服务器的IP地址，而不知道在代理服务器后面的服务器的存在。 如：某宝网站。每天访问的人数都贼多。单个服务器无法承受如此高的访问量。这时候就出现了一个新名词：分布式部署—就是通过部署多个服务器来解决访问人数限制的问题。某宝网站就是通过Nginx进行反向代理实现的。通过封装Nginx和其他组件，Tengine就诞生了。 负载均衡是什么？首先，我们先来了解一下负载量和均衡规则分别是什么。 负载量客户端发送的，Nginx反向代理服务器收到的请求数量，就是我们所说的负载量。 均衡规则请求按照一定规则进行分发到不同服务器的规则，就是均衡规则。 所以，把服务器接收到的请求按照规则分发的过程，防止出现超过服务器处理能力，响应速度慢，甚至无法连接的情况，就是负载均衡。 分类 -硬件负载均衡如F5负载均衡，数据稳定性及安全性好，但是相对造价昂贵。 -软件负载均衡利用现有的技术结合主机硬件实现的一种消息队列分发机制。 nginx支持的负载均衡调度算法 weight轮询（默认）：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。这种方式下，可以给不同的后端服务器设置一个权重值（weight），用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。 ip_hash(散列)：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。 fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块 url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在nginx作为静态服务器的情况下提高缓存效率。同样要注意nginx默认不支持这种调度算法，要使用的话需要安装nginx的hash软件包。 (摘自Sugar执着的博客)]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记2]]></title>
    <url>%2F2019%2F07%2F25%2FGit%E5%AD%A6%E4%B9%A02%2F</url>
    <content type="text"><![CDATA[十二. 合并的冲突使用命令 1$ git checkout -b feature1 创建一个新的分支 修改，add，提交之后使用命令 1$ git checkout master 切换回来， 再修改，add，提交之后使用命令 1$ git merge feature1 会出现冲突 可以用git diff 文件名来查看冲突 然后，直接进文件修改，把冲突修改掉就可以继续add和commit了 最后，删除feature1分支 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。用 1$ git log --graph 命令可以看到分支合并图。 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息 但是–no-ff 可以禁用fast forward模式 1$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 语句使用后再次使用 1$ git log --graph 命令可以看到完整的分支合并图。 十三. 分支策略首先，master分支应该是非常稳定的，也就是仅用来发布新版本 干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 代码写一半，却要先进行别的工作可以先使用命令 1$ git stash 来把当前工作现场储藏起来,然后切换到需要修复bug的分支上,使用命令 1$ git checkout master 创建临时分支 1$ git checkout -b issue-101 修改bug add commit 修复完成后，切到master分支 1$ git checkout master 然后合并 1$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101 然后回到刚才保存了一半的分支 1$ git checkout dev 可以使用命令 1$ git stash list 看到git把stash内容存在某个地方了 需要恢复可以使用命令: 1$ git stash apply ↑但是stash的内容并不会删除 要使用下面的命令来删除: 1$ git stash drop 或者一次执行两步，使用语句: 1$ git stash pop 可以在恢复的同时，也把stash内容也删了 可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash 每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。例如，使用命令 1$ git checkout -b feature-vulcan 如果要丢弃一个没有被合并过的分支，可以通过命令 1$ git branch -D &lt;name&gt; 来强行删除 十四. 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 使用命令 1$ git remote 来查看远程库的信息 用命令 1$ git remote -v 显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 使用语句 1$ git push origin master 或者直接可以使用 1$ git push 可以把该分支上的所有本地文件提交推送到远程库 • master分支是主分支，因此要时刻与远程同步 • dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； • bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； • feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 十五. 抓取分支使用命令: 1$ git clone git@github.com:michaelliao/learngit.git 把远程仓库拷贝到本地仓库 但是本地只会看到一个master分支 使用命令: 1$ git checkout -b dev origin/dev 创建一个新的分支 修改完文件，add，commit之后，使用命令 1$ git push origin dev 来把文件推送提交到远程仓库上 如果别人在你之前已经又提交过origin/dev的文件 先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接： 使用命令: 1$ git branch --set-upstream-to=origin/dev dev 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin 推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！ 如果git pull提示 1no tracking information 则说明本地分支和远程分支的链接关系没有创建，用命令 1$ git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt; 。这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 • 查看远程库信息，使用git remote -v； • 本地新建的分支如果不推送到远程，对其他人就是不可见的； • 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； • 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； • 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； • 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 十六. 标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。 在Git中打标签非常简单，首先，切换到需要打标签的分支上： 12$ git branch$ git checkout master 然后使用命令 1$ git tag v1.0 就可以打上标签 默认标签是打在最新的commit上的 如果要给之前的版本打标签，方法是找到历史提交的commit id，然后打上就可以了： 1$ git log --pretty=oneline --abbrev-commit 然后 指定commit id打标签，若对应的commit id是f52c633，敲入命令： 1$ git tag v0.9 f52c633 然后可以使用命令 1$ git tag 来查看标签 使用命令 1$ git show v0.9 可以查看标签信息 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb 然后使用命令: 1234567891011121314$ git show v0.1tag v0.1Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 22:48:43 2018 +0800version 0.1 releasedcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLdiff --git a/readme.txt b/readme.txt 可以看到说明文字 删除标签可以使用命令 1$ git tag -d v0.1 如果要推送某个标签到远程，使用命令git push origin ： 1$ git push origin v1.0 或者，一次性推送全部尚未推送到远程的本地标签： 1$ git push origin --tags 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： 1$ git tag -d v0.9 然后，从远程删除。删除命令也是push，但是格式如下： 1$ git push origin :refs/tags/v0.9 十七. 忽略特殊文件在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 可以在这上面找各个编程软件的gitignorehttps://github.com/github/gitignore 编写好你的gitignore文件之后，得到一个完整的.gitignore文件，内容如下： 12345678910111213141516# Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa 最后一步就是把.gitignore也提交到Git，就完成了！ 想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了： 1$ git add App.class 可以使用命令: 1$ git add -f App.class 强制添加到git 十八. 配置别名命令: 1$ git config --global alias.st status 可以将git status 简写位git st 命令: 1$ git config --global alias.log &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot; 可以把log目录变的好看一点 配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习路径(从上往下) by 王迎旭]]></title>
    <url>%2F2019%2F07%2F24%2FstudyGuide%2F</url>
    <content type="text"><![CDATA[所有的学习都建立在扎实的HTML,CSS,JavaScript的基础之上想入手前端，我却很迷茫不知道应该按照一个怎样的路去走。经过不断地查阅网上的资料以及实习时问周边的大佬。因此，我总结出了以下的学习路径。现在才大二，还有很长的一段路要走。 1.html5 -w3cschool 2.css3 -《精通CSS》 3.javaScript -《javaScript高级程序设计第3版》 -《javaScript DOM编程艺术第2版》 重点: 闭包，原型链，this，DOM编程, Ajax等 4.ES6 -《ES6标准入门》 重点: Promise, 箭头函数, Async/Await等 5.Node -《Node.js开发指南》 -《深入浅出Node.js》 -CNode社区 6.工程类工具 (1) 项目构建，打包，压缩: Webpack (2) 编译(将ES2015+转化为ES2015): Babel (3) 版本管理: Git(推荐，我是先学这个), SVN(较为落后) 7.框架 (1) 操作DOM: jQuery, zepto (2) 操作数据: Vue, React, Angular 重点: 设计思想，Diff算法，相关生态等 8.数据结构和算法(尽早学，培养思想) 极客时间-王争专栏 9.性能优化 -《高性能javaScript》 注意: 第五章，v8已经做优化；第九章，构建部分，现在基于webpack已经有很成熟的方案了；第十章工具不用看，直接去看chrome的devtool文档 10.网络编程 关键字: -fetch -websocket -jsonp -cors -formData -Fetch api -Ajax]]></content>
      <categories>
        <category>StudyGuide</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[服务端渲染 vs 客户端渲染]]></title>
    <url>%2F2019%2F07%2F24%2FSSR%26CSR%2F</url>
    <content type="text"><![CDATA[今天遇到了两个新概念: 服务端渲染(SSR)和客户端渲染(CSR)。他们分别是什么，各自有什么区别呢？ 服务端渲染(SSR: Server Side Render)概念: 服务器端生成html字符串，在给客户端返回html前，先在指定区域内填充数据和符号，再发送给客户端。客户端只负责解析html 优点: 前端耗时少，因为不再依赖与js文件首屏渲染快，客户端只用解析html 有利于SEO(Search Engine Optimization)搜索引擎优化，因为数据在服务器端上显示都是渲染完成的 缺点: 服务器端性能消耗较大，用户体验差 不容易维护，前端修改html和css后端也需要修改 客户端渲染(CSR: Client Side Render)概念: html作为静态文件，客户端在请求的时候，服务端不做任何处理，直接以源文件的形式返回给客户端，然后根据html上的JavaScript，生成DOM插入html(摘自:、三毛的简书) 优点: 减少了服务器端的压力 可以实现局部刷新，无需每次都请求完整的页面 缺点: 前端耗时多，渲染慢 使用了React或者其他MVVM框架之后，因为页面的DOM元素都是在客户端根据js动态生成，网络上的爬虫不会等待数据加载完成之后再爬去数据，因此可供爬虫抓取分析的内容减少。不利于SEO 所以，现在很多公司的网站都是SSR和CSR混着用，比如京东的商品列表用的是服务端渲染，目的是为了优化SEO，而京东的商品评论列表用的是客户端渲染，优化了用户体验 如何判断一个页面是服务器端渲染还是客户端渲染呢？打开一个网页，右键点击查看网页源代码，如果页面上有的东西在源代码里面也可以看得到，则是服务端渲染；反之，如果右键查看网页源代码看不到，那么便是在客户端渲染的。]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记1]]></title>
    <url>%2F2019%2F07%2F24%2FGitLearn1%2F</url>
    <content type="text"><![CDATA[以下内容均来自于廖雪峰老师的Git教程，是我学习的过程中加以理解和简化做下的笔记，以便日后查找和翻阅 一. 介绍 Git是一个版本控制工具，能实现多个成员同时共同管理开发一个或多个文档的工具。 Git是一个分布式版本控制系统，不同于CVS以及SVN等集中式版本控制系统 什么是集中式版本控制系统？ 版本库集中存放在中央服务器，每个人需要用到文件时从中央服务器取得最新的版本，然后修改完毕后再将文件传回给中央服务器。 需要联网 什么是分布式版本控制系统？每个人的电脑上都有一个完整的版本库，工作时无需联网，可相互传文件，看到各自的修改。 二. 安装 上官网下载安装 安装完成后，在桌面 Git Bash here 输入命令: 12$git config --global user.name &quot;Your Name&quot;$git config --global user.email &quot;email@example.com&quot; git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 三. 创建版本库版本库又叫仓库(Repository), 里面的所有文件都可以被Git所管理，每个文件的修改，删除都能被跟踪，也可以还原。 选择一个合适的地方，我选择用 c:/git文件夹分别输入以下命令 123$ mkdir learngit$ cd learngit$ pwd 其中，pwd命令用于显示当前目录 然后再使用命令 1$ git init 把这个目录变成Git可管理的仓库 那么空仓库就建好了，这个文件夹中会自动生成一个隐藏的.git的目录，这个目录是Git来跟踪管理版本库的，没事不要去手动修改这个目录里面的文件。 使用命令 1$ ls -ah 可以看见这个隐藏的目录 三. 注意事项1.所有的版本控制系统，只能跟踪纯文本文件的改动，无法跟踪视频，图片或者word文件的改动。 2.建议使用标准的UTF-8编码。 3.不要使用记事本保存文件，因为开发团队在每个文件开头都添加了0xefbbbf的字符，导致可能一编译就莫名其妙报错。可使用Notepad++来代替 四. 添加文件到仓库步骤: 把文件放到仓库目录下面 使用命令: 1$ git add readme.txt 再使用命令: 1$ git commit -m &quot;wrote a readme file&quot; 前者为提交的文件，后者为提交的说明 可以先分别add多个文件后提交一个说明,例如: 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 五. 查看修改状态输入命令 1$ git status 可以查看所有仓库里面的文件的修改状态，如，modified 输入命令 1$ git diff readme.txt 可以查看具体的修改情况如下 -Git is a version control system. +Git is a distributed version control system. Git is free software \ No newline at end of file 小结 • 要随时掌握工作区的状态，使用git status命令。 • 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 六. 版本回退$ ++git add++ 和 $ ++git commit++的操作就像是存档，就算数据丢失或者任何意外情况发生，只要你电脑还在，就可以恢复到之前的情况。 输入命令 1$ git log 可以查看所有提交的历史纪录 而 1$ git log --pretty=oneline 则可以更美观一些 会输出 8b7f70a69ec9b385e04204fbd968048e264280d8 (HEAD -&gt; master) add distributed 0676cc984f57df152f2d2d886cd1e4caa13132ca wrote a readme file 前面遗传乱码都是commit id(版本号), 在SVN中为1，2，3…是一个用SHA加密方式计算出来的一个非常大的数字上往下的是从新到旧的版本 1$ git reset 命令可以让版本回退 HEAD^为回到上个版本 HEAD^^为上上个版本 HEAD^100为上100个版本 以此类推… 所以使用命令 1$ git reset --hard HEAD^ 就会回到上一个版本 一旦有误删的情况，只要命令行还没关掉，就还能回到刚刚那个版本往上找版本号输入命令行 1$ git reset --hard 1094a 1094a为版本号的前5位 但是如果命令行关掉了 还是能使用命令git reflog来回到之前的版本的 七. 工作区和暂存区 工作区就是电脑里面能看到的目录，如刚刚创建的learngit 工作区里面的隐藏目录.git不是工作区，而是git的版本库 Git的版本库里面有一个称为stage的暂存区，以及Git自动创建的第一个分支master和指向master的指针HEAD Git add指令其实是把文件修改添加到暂存区 Git commit指令是把暂存区的所有内容提交到当前分支 1$ git diff HEAD -- readme.txt 命令可以查看工作区和master分支里面的文件内容区别 命令： 1$ git checkout -- readme.txt 可以把readme.txt文件在工作区的修改全部撤销 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 ==慎用此命令，因为会重写工作区！== git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 已经添加到暂存区的文件，还未提交，可以用命令: 1$ git reset HEAD readme.txt 来撤回到工作区 然后再用命令 1$ Git checkout -- reset readme.txt 来将工作区的改动恢复到原来的状态 小结 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD ，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库 git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 八. 在github上绑定ssh九. 在github上创建新的仓库使用命令 1$ git remote add origin git@github.com:WangyingxuHalo/learngit.git 来关联远程库 添加后，远程库的名字就是origin，这是Git默认的叫法 下一步，就可以把本地库(即master分支)的所有内容推送到远程库上: 使用命令: 1$ git push -u origin master -u指令指的是：不仅把版本库的内容提交，而且关联 只有第一次需要。以后就不用再输入-u指令了 以后，只要本地作了提交，就可以通过命令 1$ git push origin master 来同步到github上 十. 将远程仓库同步到本地仓库输入命令: 1$ git clone git@github.com:WangyingxuHalo/GitTry.git Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快 十一. 分支和合并创建dev分支，然后切换到dev分支 命令: 1$ git checkout -b dev git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： 12$ git branch dev$ git checkout dev git branch dev为创建名为dev的分支 git checkout dev为切换到名为dev的分支 然后我们可以用命令: 1$ git branch 来查看当前的分支 然后之后的操作就都是在dev这个branch上进行的了 可以进行git add 和 git commit 现在，dev分支的工作完成，我们就可以切换回master分支： 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 然后使用命令把dev分支的工作成果合并到master分支上： 1$ git merge dev git merge命令用于合并指定分支到当前分支。 合并完成后，就可以放心地删除dev分支了： 1$ git branch -d dev 小结 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js之获取浏览器语言]]></title>
    <url>%2F2019%2F07%2F22%2FnavigatorLanguage%2F</url>
    <content type="text"><![CDATA[navigator.language和navigator.browserLanguage&#8195;&#8195;今天看代码的时候看到了navigator.language以及navigator.browserLanguage那这些分别指代的是哪里的语言呢？我百度了一下W3C文档上写着：window.navigator.languageReturns a language tag representing the user’s preferred language. 什么意思呢？也就是说，每个浏览器会有一个语言列表的设置，用户可以设置自己的首选语言，那么window.navigator.language就会返回浏览器中用户的首选语言 例如我在chrome浏览器中使用以下语句 1console.log(window.navigator.language) 会输出 ‘zh-CN’ 而将首选语言改为英文之后会输出 ‘en’ navigator.browserLanguage和前面的类似，不过各种浏览器有不同的兼容看见一篇博客如下 IE6 IE7 IE8 Firefox Safari Chrome Opera navigator.language undefined zh-CN zh-CN navigator.userLanguage zh-cn undefined zh-cn navigator.browserLanguage zh-cn undefined zh-cn navigator.systemLanguage zh-cn undefined undefined 图片来源: https://blog.csdn.net/lvjin110/article/details/37663067 但是我自己尝试的时候IE浏览器也会打印 ‘zh-CN’可能这个版本比较老，现在IE浏览器版本高了很多吧 为了适配所有浏览器，书写代码的时候可以这么写: 1const browserLang = navigator.language || navigator.browserLanguage || &apos;zh&apos; 意思是：如果navigator.language的值为undefined，则使用navigator.browserLanguage，如果navigator.browserLanguage的值为undefined，则取’zh’ 因为可能有大小写的区别，根据写法和判断的不同，也可以写成这样： 1(navigator.language || navigator.browserLanguage).toLowerCase() 这样基本就能考虑到所有浏览器的兼容性了]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
</search>
