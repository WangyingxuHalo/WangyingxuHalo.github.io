<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王迎旭的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-05T20:00:56.363Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Siri Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法练习--反转链表二</title>
    <link href="http://yoursite.com/2019/09/06/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A82/"/>
    <id>http://yoursite.com/2019/09/06/算法练习-反转链表2/</id>
    <published>2019-09-05T19:59:46.497Z</published>
    <updated>2019-09-05T20:00:56.363Z</updated>
    
    <content type="html"><![CDATA[<p>反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><p>说明:<br>1 ≤ m ≤ n ≤ 链表长度。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p><hr><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>解析：<br>这题和之前做过的反转链表有点类似，我们可以先让curr这个指针走到m点之后，再跟反转链表一样，prev和curr迭代改变链表方向，直到n点。最后再将剩余的部分用.next = xxx 连接起来即可。</p><p>js代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var reverseBetween = function(head, m, n) &#123;</span><br><span class="line">    if(m &gt;= n || m &lt; 0 || n &lt; 0) return head;</span><br><span class="line">    var prev = null;</span><br><span class="line">    var curr = head;</span><br><span class="line">    var i = 1;</span><br><span class="line">    while(i &lt; m &amp;&amp; curr)&#123;  //让curr走到m节点</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = prev; //t1为m节点前一个节点</span><br><span class="line">    t2 = curr; //t2为m节点后一个几点</span><br><span class="line">    while(i&lt;=n &amp;&amp; curr)&#123; //反转m到n之间的节点</span><br><span class="line">        nextNode = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextNode;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(m == 1)&#123;  //特殊情况，若m为1，则需要将第一个节点指向n节点的后一个节点</span><br><span class="line">        t2.next = curr;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">    //将剩余部分连接</span><br><span class="line">    t1.next = prev;</span><br><span class="line">    t2.next = curr;</span><br><span class="line">    return head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这段代码效率不高，因此我去看了网上效率更高的代码。</p><hr><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>其实就是在链表开头插入了一个哨兵节点。在m等于1的时候，它指向了n节点。在m不等于1的时候，它指向了第一个几点。因此省去了一步判断条件if(m==1).导致运行效率提高了不少。</p><p>js代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var reverseBetween = function(head, m, n) &#123;</span><br><span class="line">    var first = new ListNode(0);</span><br><span class="line">    first.next = head;</span><br><span class="line">    var prev = first;</span><br><span class="line">    var curr = head;</span><br><span class="line">    var i = 1;</span><br><span class="line">    while(i &lt; m &amp;&amp; curr)&#123;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    t1 = prev;</span><br><span class="line">    t2 = curr;</span><br><span class="line">    while(i &lt;= n &amp;&amp; curr)&#123;</span><br><span class="line">        nextNode = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextNode;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    t1.next = prev;</span><br><span class="line">    t2.next = curr;</span><br><span class="line">    return first.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>原理：代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(let i = m; i &lt; n; i++)&#123;</span><br><span class="line">       var next1 = head.next;</span><br><span class="line">       head.next = next1.next;</span><br><span class="line">       next1.next = pre.next;</span><br><span class="line">       pre.next = next1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以让m到n节点的列表逆转</p><p>js代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var reverseBetween = function(head, m, n) &#123;</span><br><span class="line">    var first = new ListNode(0);</span><br><span class="line">    first.next = head;</span><br><span class="line">    var pre = first;</span><br><span class="line">    for(let i = 1; i &lt; m; i++)&#123;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head = pre.next;</span><br><span class="line">    for(let i = m; i &lt; n; i++)&#123;</span><br><span class="line">        var next1 = head.next;</span><br><span class="line">        head.next = next1.next;</span><br><span class="line">        next1.next = pre.next;</span><br><span class="line">        pre.next = next1;</span><br><span class="line">    &#125;</span><br><span class="line">    return first.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。&lt;/p&gt;
&lt;p&gt;说明:&lt;br&gt;1 ≤ m ≤ n ≤ 链表长度。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4&lt;br&gt;输出
      
    
    </summary>
    
      <category term="算法练习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>插入排序</title>
    <link href="http://yoursite.com/2019/09/05/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/09/05/插入排序/</id>
    <published>2019-09-04T18:45:05.390Z</published>
    <updated>2019-09-04T18:44:16.750Z</updated>
    
    <content type="html"><![CDATA[<h3 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h3><p>插入排序分为两种:  </p><blockquote><ol><li><p><strong>直接插入排序</strong>(Straight Insertion Sort)</p></li><li><p><strong>二分插入排序</strong>(Binary Insertion Sort)</p></li></ol></blockquote><h4 id="一-直接插入排序"><a href="#一-直接插入排序" class="headerlink" title="一. 直接插入排序"></a>一. 直接插入排序</h4><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>最好：n-1= O(n) (刚好升序排列)<br>最坏: 1+2+3+…+n-1 = n*(n-1)/2 = O(n^2)</p><h2 id="平均起来是O-n-n-2-2-O-n-2"><a href="#平均起来是O-n-n-2-2-O-n-2" class="headerlink" title="平均起来是O((n+n^2)/2) = O(n^2)"></a>平均起来是O((n+n^2)/2) = O(n^2)</h2><h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>O(1)，因为只有使用一个temp作为原数组以外的额外存储空间,所以为O(1)</p><hr><h5 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h5><p>稳定(Stable)   </p><h2 id="稳定的意思是：如果一个算法稳定，那么若有N个与关键字相同的数据-比如5个A-，那么这些相同的关键字排序后仍按原先序列的顺序排列。如果一个算法不稳定，那么若有N个与关键字相同的数据，可能会出现排序后顺序不同的情况。"><a href="#稳定的意思是：如果一个算法稳定，那么若有N个与关键字相同的数据-比如5个A-，那么这些相同的关键字排序后仍按原先序列的顺序排列。如果一个算法不稳定，那么若有N个与关键字相同的数据，可能会出现排序后顺序不同的情况。" class="headerlink" title="稳定的意思是：如果一个算法稳定，那么若有N个与关键字相同的数据(比如5个A)，那么这些相同的关键字排序后仍按原先序列的顺序排列。如果一个算法不稳定，那么若有N个与关键字相同的数据，可能会出现排序后顺序不同的情况。"></a>稳定的意思是：如果一个算法稳定，那么若有N个与关键字相同的数据(比如5个A)，那么这些相同的关键字排序后<strong>仍按原先序列的顺序排列</strong>。如果一个算法不稳定，那么若有N个与关键字相同的数据，可能会出现排序后顺序不同的情况。</h2><p>原理为：将一组数据分为两组，<strong>已排序组</strong>和<strong>未排序组</strong></p><table><thead><tr><th>已排序组</th><th>未排序组</th></tr></thead></table><p>刚开始已排序组中只有第一个元素。每次从未排序组中取出一个元素，与已排序组的多个元素进行比较，找到合适的位置并将其插入到已排序组当中。</p><p>js代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function insertionSort(list1) &#123;</span><br><span class="line">                for(let i = 1; i &lt; list1.length; i++)&#123;</span><br><span class="line">                    var temp = list1[i];</span><br><span class="line">                    var j = i - 1;</span><br><span class="line">                    while(j &gt;= 0 &amp;&amp; list1[j] &gt; temp)&#123;</span><br><span class="line">                        list1[j + 1] = list1[j];</span><br><span class="line">                        j -= 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    list1[j+1] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">                return Array.prototype.join.call(list1, &apos;,&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">            alert(insertionSort([1,5,3,7,2]));</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1,2,3,5,7</span><br></pre></td></tr></table></figure><p>其中，<br><strong>return Array.prototype.join.call(list1, ‘,’);</strong><br>语句表示将对象数组转化为字符串，用’,’连接在一起。</p><h4 id="二-二分插入排序"><a href="#二-二分插入排序" class="headerlink" title="二. 二分插入排序"></a>二. 二分插入排序</h4><h5 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p><strong>最好</strong>：O(nlogn)<br>最好的情况是不用交换，刚好正序。那么只用考虑查找的情况。外部O(n)次循环，内部只用O(logn)次查找，所以乘起来为O(nlogn)。</p><p><strong>最坏</strong>: O(n^2)<br>二分插入其实简化的是查找的效率，最主要的工作还是在交换上。交换的话最坏的情况是倒序，那么交换的时间为1+2+…+n-1 = O(n^2)。</p><hr><h5 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>O(1),因为只有用到temp, low, high, mid, j等额外空间，为常数个</p><hr><h5 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h5><p>稳定</p><p>原理：在插入第i个元素时，把对面的0~i-1元素进行折半。先跟中间的那个元素比，如果比那个元素小，则再进行折半，否则对后半进行折半。直到left&lt;right。最后将i-1到目标元素之间的元素全部后移一位，再把元素放到位置i上。</p><hr><p>js代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function insertionSort(list1) &#123;</span><br><span class="line">     for(let i = 1; i &lt; list1.length; i++)&#123;</span><br><span class="line">       var temp = list1[i];</span><br><span class="line">       var low = 0;</span><br><span class="line">       var high = i - 1;</span><br><span class="line">       var mid = -1;</span><br><span class="line">       while(low &lt;= high)&#123;</span><br><span class="line">           mid = Math.floor(low + (high - low) / 2);</span><br><span class="line">           if(list1[mid] &gt; temp)&#123;</span><br><span class="line">               high = mid - 1;</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               low = mid + 1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       for(let j = i - 1; j &gt;= low; j--)&#123;</span><br><span class="line">           list1[j+1] = list1[j];</span><br><span class="line">       &#125;</span><br><span class="line">       list1[low] = temp;</span><br><span class="line">     &#125;</span><br><span class="line">     return Array.prototype.join.call(list1, &apos;,&apos;);</span><br><span class="line"> &#125;</span><br><span class="line">  alert(insertionSort([1,5,3,7,2]));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;插入排序-Insertion-Sort&quot;&gt;&lt;a href=&quot;#插入排序-Insertion-Sort&quot; class=&quot;headerlink&quot; title=&quot;插入排序(Insertion Sort)&quot;&gt;&lt;/a&gt;插入排序(Insertion Sort)&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>各量级时间复杂度大小比较</title>
    <link href="http://yoursite.com/2019/09/05/%E5%90%84%E9%87%8F%E7%BA%A7%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83/"/>
    <id>http://yoursite.com/2019/09/05/各量级时间复杂度大小比较/</id>
    <published>2019-09-04T18:41:39.156Z</published>
    <updated>2019-09-04T18:42:48.058Z</updated>
    
    <content type="html"><![CDATA[<p>在分析各种算法的时间复杂度问题中，我们会遇到各种量级的函数。当n很小时，其实是难以区分的。但是在n增大的时候，特别是接近于无穷大的时候，它们之间的大小就显而易见：</p><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n)</p><p>摘自：<a href="https://blog.csdn.net/chenguanghan123/article/details/83478259" target="_blank" rel="noopener">陈广晗-Clare的博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在分析各种算法的时间复杂度问题中，我们会遇到各种量级的函数。当n很小时，其实是难以区分的。但是在n增大的时候，特别是接近于无穷大的时候，它们之间的大小就显而易见：&lt;/p&gt;
&lt;p&gt;O(1) &amp;lt; O(logn) &amp;lt; O(n) &amp;lt; O(nlogn) &amp;lt; O
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法练习——反转链表</title>
    <link href="http://yoursite.com/2019/09/02/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/09/02/反转链表/</id>
    <published>2019-09-02T13:36:36.492Z</published>
    <updated>2019-09-05T20:01:29.013Z</updated>
    
    <content type="html"><![CDATA[<p>反转一个单链表。</p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h4 id="解法1：迭代"><a href="#解法1：迭代" class="headerlink" title="解法1：迭代"></a>解法1：迭代</h4><p>在迭代遍历整个链表的时候，将每个当前节点的next指针指向prev，也就是前一个指针。遍历完整个链表的时候，所有的指针都会指向前一个指针了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    var prev = null;</span><br><span class="line">    var curr = head;</span><br><span class="line">    while(curr != null)&#123;</span><br><span class="line">        newNode = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="解法2：递归"><a href="#解法2：递归" class="headerlink" title="解法2：递归"></a>解法2：递归</h4><p>reverseList嵌套reverseList。在递归的过程中，将每个原本指向后一个节点的方向改为指向前一个节点。最后return reverse表示返回最后一个节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var reverseList = function(head) &#123;</span><br><span class="line">    if(head == null || head.next == null)&#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    var reverse = reverseList(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = null;</span><br><span class="line">    return reverse;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;反转一个单链表。&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;br&gt;输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/p&gt;
&lt;h4 id=&quot;解法1：迭代&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="算法练习" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>用Canvas制作灰度图片</title>
    <link href="http://yoursite.com/2019/08/01/%E7%94%A8canvas%E5%88%B6%E4%BD%9C%E7%81%B0%E5%BA%A6%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2019/08/01/用canvas制作灰度图片/</id>
    <published>2019-08-01T01:48:24.148Z</published>
    <updated>2019-08-01T01:52:40.761Z</updated>
    
    <content type="html"><![CDATA[<p>大家都知道，Canvas标签是HTML5中新增的一种标签。今天我为了实现把图片变灰的效果，使用Canvas标签的时候，遇到了这种语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.getImageData(0,0,img.width,img.height);</span><br></pre></td></tr></table></figure><p>以及这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.putImageData(c,0,0,0,0,c.width,c.height);</span><br></pre></td></tr></table></figure><p>那么它们分别代表什么意思？又是怎么实现图片变灰的效果的呢？</p><h4 id="getImageData"><a href="#getImageData" class="headerlink" title=".getImageData()"></a>.getImageData()</h4><p>CanvasRenderingContext2D.getImageData(sx, sy, sw, sh) 返回一个 ImageData 对象，用来描述 canvas 区域隐含的像素数据，这个区域通过矩形表示，起始点为(sx, sy)、宽为sw、高为sh。</p><blockquote><p>sx：将要被提取的图像数据矩形区域的左上角 x 坐标。</p><p>sy：将要被提取的图像数据矩形区域的左上角 y 坐标。</p><p>sw：将要被提取的图像数据矩形区域的宽度。</p><p>sh：将要被提取的图像数据矩形区域的高度。</p></blockquote><p><strong>ImageData对象</strong>有三个属性: height, width 和data</p><p>-heigh属性表示ImageData的实际高度，等于getImageData的sh属性</p><p>-width属性表示ImageData的实际宽度，等于getImageData的sw属性</p><p>-data属性是一个一维数组，包含RGBA的数据</p><p>例：<br>在宽度为width，高度为height的图像中<br>第(x+1)行，第(y+1)列的像素为(一个RGBA为一个单位)：   </p><blockquote><p>R = imageData.data[(4<em>x)</em>width + (y * 4)]</p><p>G = imageData.data[(4<em>x)</em>width + (y * 4) +1]</p><p>B = imageData.data[(4<em>x)</em>width + (y * 4) +2]</p><p>A = imageData.data[(4<em>x)</em>width + (y * 4) +3]</p></blockquote><h4 id="putImageData"><a href="#putImageData" class="headerlink" title=".putImageData()"></a>.putImageData()</h4><p>这条语句的语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight);</span><br><span class="line">或</span><br><span class="line">ctx.putImageData(imagedata, dx, dy);</span><br></pre></td></tr></table></figure><p>dx为源图像数据在目标画布中x轴方向位置偏移量</p><p>dy为源图像数据在目标画布中y轴方向位置偏移量</p><p>dirtyX为可选项，是源图像区域中，矩形区域左上角的位置。默认是整个图像数据的左上角（x 坐标）</p><p>dirtyY为可选项，是矩形区域左上角的位置。默认是整个图像数据的左上角（y 坐标）</p><p>dirtyWidth为可选项，是矩形区域的宽度。默认是图像数据的宽度。</p><p>dirtyHeight为可选项，是矩形区域的高度。默认是图像数据的高度。</p><h4 id="return-canvas-toDataURL"><a href="#return-canvas-toDataURL" class="headerlink" title="return canvas.toDataURL()"></a>return canvas.toDataURL()</h4><p>这条语句可以将画布内容转化为图片。在制作完灰度画布canvas之后用这个语法可以return 这个灰度的img类型图片。</p><hr><p>参考资料：   </p><p><a href="https://blog.csdn.net/FE_dev/article/details/82586698" target="_blank" rel="noopener">FEWY的博客</a></p><p><a href="https://www.cnblogs.com/Renyi-Fan/p/8142608.html" target="_blank" rel="noopener">范仁义的博客</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/putImageData" target="_blank" rel="noopener">MDN Web docs</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家都知道，Canvas标签是HTML5中新增的一种标签。今天我为了实现把图片变灰的效果，使用Canvas标签的时候，遇到了这种语法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="HTML5" scheme="http://yoursite.com/categories/HTML5/"/>
    
    
  </entry>
  
  <entry>
    <title>从输入URL到页面加载完成发生了什么？</title>
    <link href="http://yoursite.com/2019/07/31/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90/"/>
    <id>http://yoursite.com/2019/07/31/从输入URL到页面加载完成/</id>
    <published>2019-07-31T09:40:18.007Z</published>
    <updated>2019-07-31T09:41:10.594Z</updated>
    
    <content type="html"><![CDATA[<p>今天在app“开发者头条”上看到一篇文章：<strong>输入URL到展现涉及的缓存环节。</strong></p><p>作为前端小白，我当然不知道从输入URL到展现涉及的缓存环节了！</p><p>首先，我们可以先了解以下从输入URL到页面加载完成的过程中都发生了什么！</p><p><em>(以下文章主要来自于<a href="https://www.jianshu.com/p/a877684a4cdd" target="_blank" rel="noopener">BULL_DEBUG的博客</a>，中间加上我对于不同概念的查阅和理解)</em></p><h3 id="从输入URL到页面加载完成的过程中都发生了什么？"><a href="#从输入URL到页面加载完成的过程中都发生了什么？" class="headerlink" title="从输入URL到页面加载完成的过程中都发生了什么？"></a>从输入URL到页面加载完成的过程中都发生了什么？</h3><p>总体来说可以分为6个部分！<br>分别是</p><blockquote><ol><li>DNS连接   </li><li>TCP连接   </li><li>发送HTTP请求   </li><li>服务器处理请求并发送HTTP报文   </li><li>浏览器解析渲染页面   </li><li>连接结束</li></ol></blockquote><p>具体过程：</p><h4 id="1-DNS解析"><a href="#1-DNS解析" class="headerlink" title="1.DNS解析"></a>1.DNS解析</h4><p>DNS域名解析是把域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务。我们现在网上输入的各种网址其实不是真正意义上的各种网站地址。互联网上每一台计算机的唯一标识是他的IP地址。所以我们输入网站之后，经由DNS域名解析(其实跟翻译差不多)，实现了从域名到IP地址的转换。</p><hr><p>如果要查找Google的域名地址，就会首先在本地域名服务器中查找IP地址。</p><p>(1)如果本地域名服务器中没有找到，本地域名服务器会向根域名服务器发送一个请求。</p><p>==这里出现了一个问题：本地域名服务器是啥？根域名服务器又是什么？==</p><p>百度了一哈，</p><blockquote><p><strong>本地DNS</strong>一般是指你电脑上网时IPv4或者IPv6设置中填写的那个DNS。这个有可能是手工指定的或者是DHCP自动分配的。<br>如果你的电脑是直连运营商网络，一般默认设置情况下DNS为DHCP分配到的运营商的服务器地址。如果你的电脑和运营商之间还加了无线或者有线路由，那极有可能路由器本身还内置了一个DNS转发器，这玩意的作用是将发往他所有的DNS请求转发到上层DNS。此时由于路由器本身也接管了下挂电脑的DHCP服务，所以它分配给下面电脑的DNS地址就是它自身，所以你能看到电脑的DNS分配到的可能是192.168.1.1。实际上就是路由器自身，而路由器的DNS转发器将请求转发到上层ISP的DNS。所以这里说DNS是局域网或者是运营商的都可以（因为最终都是转发到运营商，小细节不用纠结）。</p></blockquote><p>来源: <a href="https://www.cnblogs.com/lidabo/p/8426751.html" target="_blank" rel="noopener">DoubleLi的博客</a></p><blockquote><p><strong>根域名服务器</strong>主要用来管理互联网的主目录。全世界IPv4根服务器只有13台，1个为主根服务器在美国。其余12个均为辅根服务器，其中9个在美国，欧洲2个，位于英国和瑞典，亚洲1个位于日本。</p></blockquote><p>(2)如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去，直到最后找到了Google的IP地址并将其缓存到本地。</p><h4 id="2-DNS缓存"><a href="#2-DNS缓存" class="headerlink" title="2.DNS缓存"></a>2.DNS缓存</h4><p>在请求Google的IP地址的时候，这个过程中有多个请求。如果每次都经历这么多步骤，肯定会太耗时间。这个时候DNS缓存就起到了重要的作用。</p><h5 id="缓存类型"><a href="#缓存类型" class="headerlink" title="缓存类型"></a>缓存类型</h5><p>DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p><h4 id="3-DNS负载均衡"><a href="#3-DNS负载均衡" class="headerlink" title="3.DNS负载均衡"></a>3.DNS负载均衡</h4><p>但是其实DNS解析返回的IP地址并不都是一样的。一个机器不可能可以同时处理成千上万个请求。用户需要的只是响应他的请求，而不在意是哪个机器响应他的请求。所以DNS可以根据比如用户的地址，每台机器的负载量等等来返回一个合适的IP地址给用户。这就是DNS负载均衡，也叫做DNS重定向技术。</p><h4 id="4-TCP连接"><a href="#4-TCP连接" class="headerlink" title="4.TCP连接"></a>4.TCP连接</h4><p>HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。</p><h4 id="5-HTTPS协议"><a href="#5-HTTPS协议" class="headerlink" title="5.HTTPS协议"></a>5.HTTPS协议</h4><p>HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的风险。</p><p>那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。</p><h4 id="6-HTTPS过程"><a href="#6-HTTPS过程" class="headerlink" title="6.HTTPS过程"></a>6.HTTPS过程</h4><p>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。(TLS/SSL握手这个现在我暂时不太了解，日后我会查阅相关知识，再写一篇博客来介绍)   </p><p>HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。</p><h4 id="7-HTTP请求"><a href="#7-HTTP请求" class="headerlink" title="7.HTTP请求"></a>7.HTTP请求</h4><p>HTTP请求主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。</p><h5 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h5><p>由三部分组成：  </p><blockquote><p>-请求行   </p><p>-请求报头:<br>  包含Cookie等信息</p><p>-请求正文:<br>    当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。</p></blockquote><h4 id="8-服务器处理请求并返回HTTP报文"><a href="#8-服务器处理请求并返回HTTP报文" class="headerlink" title="8.服务器处理请求并返回HTTP报文"></a>8.服务器处理请求并返回HTTP报文</h4><p>后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行。后端服务器有：Tomcat, Jetty和Netty等等。</p><p>HTTP响应报文也是由三部分组成:</p><blockquote><p>-状态码  </p></blockquote><blockquote><p>-响应报头<br>  常见的响应报头字段有:Server,Connection…</p></blockquote><blockquote><p>-响应报文<br>服务器返回给浏览器的文本信息，通常HTML, CSS, JS,图片等文件就放在这一部分。</p></blockquote><h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><p>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p><blockquote><p>1xx：指示信息–表示请求已接收，继续处理。<br>2xx：成功–表示请求已被成功接收、理解、接受。<br>3xx：重定向–要完成请求必须进行更进一步的操作。<br>4xx：客户端错误–请求有语法错误或请求无法实现。<br>5xx：服务器端错误–服务器未能实现合法的请求。</p></blockquote><h4 id="9-浏览器解析渲染页面"><a href="#9-浏览器解析渲染页面" class="headerlink" title="9.浏览器解析渲染页面"></a>9.浏览器解析渲染页面</h4><blockquote><p>JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。</p><p>浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。</p></blockquote><h4 id="10-Web优化"><a href="#10-Web优化" class="headerlink" title="10.Web优化"></a>10.Web优化</h4><p>如何尽快的加载资源？答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow，所以围绕这一部分就是考虑如何减少reflow的次数。</p><hr><p>注：这篇文章内容主要来自于<a href="https://www.jianshu.com/p/a877684a4cdd" target="_blank" rel="noopener">BULL_DEBUG的博客</a>，因为读后有所收获！加上了自己查阅相关知识的内容，为了日后温习知识，收录到我的博客当中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在app“开发者头条”上看到一篇文章：&lt;strong&gt;输入URL到展现涉及的缓存环节。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为前端小白，我当然不知道从输入URL到展现涉及的缓存环节了！&lt;/p&gt;
&lt;p&gt;首先，我们可以先了解以下从输入URL到页面加载完成的过程中都发生了什么！
      
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>XMLHttpRequest.send()函数</title>
    <link href="http://yoursite.com/2019/07/29/requestSend/"/>
    <id>http://yoursite.com/2019/07/29/requestSend/</id>
    <published>2019-07-29T09:43:00.642Z</published>
    <updated>2019-07-29T09:44:23.407Z</updated>
    
    <content type="html"><![CDATA[<p>request.send(null)<br>今天遇到了Ajax请求当中的request.send(null)。但是不知道这句话由什么用处。所以上网搜了以下。</p><p>我遇到的例子是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function getNewContent() &#123;</span><br><span class="line">    var request = getHTTPObject();</span><br><span class="line">    if(request)&#123;</span><br><span class="line">        request.open(&quot;GET&quot;,&quot;example.txt&quot;,true);</span><br><span class="line">        request.onreadyStateChange = function() &#123;</span><br><span class="line">            if(request.readyState == 4)&#123;</span><br><span class="line">                alert(&quot;Response Received&quot;);</span><br><span class="line">                var para = document.createElement(&quot;p&quot;);</span><br><span class="line">                var txt = document.createTextNode(request.responseText);</span><br><span class="line">                para.appendChild(txt);</span><br><span class="line">                document.getElementById(&quot;new&quot;).appendChild(para);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ;</span><br><span class="line">        request.send(null);</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        alert(&quot;Sorry, your browser doesn&apos;t support XMLHttpRequest&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    alert(&quot;Function Done&quot;);</span><br><span class="line">&#125;</span><br><span class="line">addLoadEvent(getNewContent);</span><br></pre></td></tr></table></figure><p>百度了一下</p><p>这个请求分为两种：<br><strong>POST请求和GET请求</strong>。</p><p>如果是GET请求，就像例子里一样，不用在send()函数里面加内容，放个null就好。因为是在url里面传参数的，如下例子所示：</p><p>e.g.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;GET&quot;,&quot;testServlet?name=&quot;+userName,true);</span><br><span class="line">xmlhttp.send(null);</span><br></pre></td></tr></table></figure><br><p>如果是POST请求，是要加内容的。因为POST请求不是在url里面传参数的。  </p><p>e.g.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(&quot;POST&quot;,&quot;testServlet&quot;,true);</span><br><span class="line">//POST方式需要自己设置http的请求头</span><br><span class="line">xmlhttp.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">//POST方式发送数据</span><br><span class="line">xmlhttp.send(&quot;name=&quot;+userName);</span><br></pre></td></tr></table></figure><br>Fighting！]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;request.send(null)&lt;br&gt;今天遇到了Ajax请求当中的request.send(null)。但是不知道这句话由什么用处。所以上网搜了以下。&lt;/p&gt;
&lt;p&gt;我遇到的例子是这样的：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>同源策略和跨域(上)</title>
    <link href="http://yoursite.com/2019/07/29/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2019/07/29/同源策略/</id>
    <published>2019-07-29T09:07:27.211Z</published>
    <updated>2019-07-29T09:08:54.874Z</updated>
    
    <content type="html"><![CDATA[<p>今天看《JavaScript DOM编程艺术》这本书的时候，看到了一个新的概念：<strong>同源策略</strong>。<br><br><br>书上说：   </p><blockquote><p>在使用Ajax时，千万要注意同源策略。使用XMLHttpRequest对象发送的请求只能访问与其所在的HTML处于同一个域中的数据，不能向其他域发送请求。</p></blockquote><p>这段话看得我一阵懵。啥是同源策略？啥是同一个域？啥是其他域？</p><p>依旧是不同就去百度。</p><br><h4 id="同源是什么？"><a href="#同源是什么？" class="headerlink" title="同源是什么？"></a>同源是什么？</h4><p>同源是指域名，协议，端口相同。</p><blockquote><p>1.域名: 都属于 <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a>   </p><p>2.协议:要么都是http，要么都是https   </p><p>3.端口：端口号要相同。如:80和:8080就不是同一个端口</p></blockquote><br><h4 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h4><p>这是浏览器的一个<strong>安全功能</strong>，不同源的客户端脚本在没有明确<strong>授权</strong>的情况下，不能读写对方资源。所以a.com的下的js脚本采用ajax读写b.com中的文件数据是会报错的。为了保护本地数据不被js返回回来的数据污染，浏览器会拦截客户端发出的请求回来的数据接收。即便请求发送了，服务器响应了，但是<strong>不会被浏览器接收</strong>！！</p><p>如果没有同源策略，那么就会发生<a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html" target="_blank" rel="noopener">CSRF攻击</a>(来源:陈曦明的博客)。这里讲的很清楚！！！简洁地来说就是利用你登录网站保存下来的cookie来向你登录过的网站发送非法请求。</p><p>==注意==：<br>这里的话，表单提交和链接什么的是不会受到同源策略的影响的，这些不是http请求！！！</p><p>那我就很疑惑了，平常我们写的网页呀什么的不都是往各种网站上去请求API的吗？这个要是被限制住了怎么办？</p><br><h3 id="同源策略下的正确接口请求"><a href="#同源策略下的正确接口请求" class="headerlink" title="同源策略下的正确接口请求"></a>同源策略下的正确接口请求</h3><h4 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h4><h4 id="2-空iframe加form"><a href="#2-空iframe加form" class="headerlink" title="2.空iframe加form"></a>2.空iframe加form</h4><h4 id="3-CORS"><a href="#3-CORS" class="headerlink" title="3.CORS"></a>3.CORS</h4><h4 id="4-代理"><a href="#4-代理" class="headerlink" title="4.代理"></a>4.代理</h4><p>网上都有解释，<br>但是我现在基础还不够，等到学完js和一些后端语言之后再回来再看可能收获更大！<br>那就先完成这个内容的上篇，以后再回来完成下篇！</p><p>Fighting！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天看《JavaScript DOM编程艺术》这本书的时候，看到了一个新的概念：&lt;strong&gt;同源策略&lt;/strong&gt;。&lt;br&gt;&lt;br&gt;&lt;br&gt;书上说：   &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在使用Ajax时，千万要注意同源策略。使用XMLHttpRequest
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>前端页面由哪三层构成？</title>
    <link href="http://yoursite.com/2019/07/26/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E7%94%B1%E5%93%AA%E4%B8%89%E5%B1%82%E6%9E%84%E6%88%90%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/07/26/前端页面由哪三层构成？/</id>
    <published>2019-07-26T09:27:49.916Z</published>
    <updated>2019-09-05T20:06:23.215Z</updated>
    
    <content type="html"><![CDATA[<p>今天看书的时候，看到了一句话：</p><blockquote><p>网页的行为层(JavaScript)是作用于其结构层(HTML)之上的，还是两种代码混杂在一起？</p></blockquote><p>这句话貌似没有看起来这么简单，难道行为层就是JavaScript，结构层就是HTML？</p><p>老规矩，百度。</p><p><strong>最准确的网页设计思路是把网页分成三个层次，即：结构层、表示层、行为层。</strong></p><hr><h3 id="网页的结构层（structural-layer）"><a href="#网页的结构层（structural-layer）" class="headerlink" title="网页的结构层（structural layer）"></a>网页的结构层（structural layer）</h3><p>由HTML或XHTML之类的语言负责创建，标签对网页内容的语义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。</p><hr><h3 id="网页的表示层（presentation-layer）"><a href="#网页的表示层（presentation-layer）" class="headerlink" title="网页的表示层（presentation layer）"></a>网页的表示层（presentation layer）</h3><p>由CSS负责创建，负责了如何显示有关信息的问题。</p><hr><h3 id="网页的行为层（behavior-layer）"><a href="#网页的行为层（behavior-layer）" class="headerlink" title="网页的行为层（behavior layer）"></a>网页的行为层（behavior layer）</h3><p>由JavaScript和DOM负责，负责了内容该如何对事件做出反应</p><p>easy！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天看书的时候，看到了一句话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;网页的行为层(JavaScript)是作用于其结构层(HTML)之上的，还是两种代码混杂在一起？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这句话貌似没有看起来这么简单，难道行为层就是JavaScrip
      
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>单页面应用（SPA）和多页面应用 （MPA）</title>
    <link href="http://yoursite.com/2019/07/26/%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2019/07/26/单页面应用和多页面应用/</id>
    <published>2019-07-26T01:28:54.080Z</published>
    <updated>2019-07-26T01:29:51.341Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是单页面应用-SinglePage-Application"><a href="#什么是单页面应用-SinglePage-Application" class="headerlink" title="什么是单页面应用(SinglePage Application)?"></a>什么是单页面应用(SinglePage Application)?</h4><p>概念:<br>只有一张Web页面的应用。第一次进入页面时会有一次html请求，公共页面加载一次；切换到其他组件时，路径也相应变化，但是并没有新的html请求。url变化时，js动态地将页面的内容清除，然后将另外一个页面的内容挂载到当前页面上。这时，路由由前端来做，而不是由后端来实现。</p><p>优点：</p><blockquote><p>页面跳转用js渲染技术，页面切换快。</p></blockquote><p>缺点:</p><blockquote><p>首屏加载时间慢，SEO差。</p></blockquote><hr><h4 id="什么是多页面应用-MultiPage-Application-？"><a href="#什么是多页面应用-MultiPage-Application-？" class="headerlink" title="什么是多页面应用(MultiPage Application)？"></a>什么是多页面应用(MultiPage Application)？</h4><p>概念:<br>由多个完整页面构成，页面之间的跳转是从一个页面跳转到另一个页面。每次跳转都有一个新的http请求，页面切换较慢。</p><p>优点: </p><blockquote><p>利于SEO，因为页面所有的内容都放在html中，利于爬虫抓取。</p><p>首屏时间快，因为只有一个http请求，没有其他js渲染</p></blockquote><p>缺点:</p><blockquote><p>页面切换较慢，用户体验较差</p></blockquote><hr><h4 id="SPA和MPA的比较"><a href="#SPA和MPA的比较" class="headerlink" title="SPA和MPA的比较"></a>SPA和MPA的比较</h4><p>||多页面应用MPA|单页面应用SPA|</p><table><thead><tr><th></th><th>多页面应用模式</th><th>单页面应用模式</th></tr></thead><tbody><tr><td>应用构成</td><td>由多个完整页面构成</td><td>一个外壳页面和多个页面片段构成</td></tr><tr><td>跳转方式</td><td>页面之间的跳转是从一个页面到另一个页面</td><td>一个页面片段删除或隐藏，加载另一个页面片段并显示。片段间的模拟跳转，没有开壳页面</td></tr><tr><td>跳转后公共资源是否重新加载</td><td>是</td><td>否</td></tr><tr><td>URL模式</td><td><a href="http://xxx/page1.html和http://xxx/page2.html" target="_blank" rel="noopener">http://xxx/page1.html和http://xxx/page2.html</a></td><td><a href="http://xxx/shell.html#page1和http://xxx/shell.html#page2" target="_blank" rel="noopener">http://xxx/shell.html#page1和http://xxx/shell.html#page2</a></td></tr><tr><td>用户体验</td><td>页面间切换加载慢，不流畅，用户体验差，尤其在移动端</td><td>页面片段间切换快，用户体验好，包括移动设备</td></tr><tr><td>能否实现转场动画</td><td>否</td><td>容易实现（手机APP动效）</td></tr><tr><td>页面间传递数据</td><td>依赖URL、cookie或者localstorage，实现麻烦</td><td>页面传递数据容易（Vuex或Vue中的父子组件通讯props对象）</td></tr><tr><td>搜索引擎优化（SEO）</td><td>可以直接做</td><td>需要单独方案（SSR）</td></tr><tr><td>特别适用的范围</td><td>需要对搜索引擎友好的网站</td><td>对体验要求高，特别是移动应用</td></tr><tr><td>开发难度</td><td>较低，框架选择容易</td><td>较高，需要专门的框架来降低这种模式的开发难度</td></tr></tbody></table><p>表格来源：<a href="https://www.jianshu.com/p/a02eb15d2d70" target="_blank" rel="noopener">洛卿九的简书</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是单页面应用-SinglePage-Application&quot;&gt;&lt;a href=&quot;#什么是单页面应用-SinglePage-Application&quot; class=&quot;headerlink&quot; title=&quot;什么是单页面应用(SinglePage Applicatio
      
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是正向代理，反向代理和负载均衡？</title>
    <link href="http://yoursite.com/2019/07/25/%E6%AD%A3%E5%8F%8D%E4%BB%A3%E7%90%86%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2019/07/25/正反代理和负载均衡/</id>
    <published>2019-07-25T09:52:43.441Z</published>
    <updated>2019-07-26T00:47:54.244Z</updated>
    
    <content type="html"><![CDATA[<p>以前没有接触过Nginx，今天偶然看到这个新名词，不自觉就去百度了一下。</p><h4 id="什么是Nginx"><a href="#什么是Nginx" class="headerlink" title="什么是Nginx?"></a>什么是Nginx?</h4><blockquote><p>nginx是一款自由的、开源的、高性能的<strong>HTTP服务器</strong>和<strong>反向代理服务器</strong>；同时也是一个<strong>电子邮件(IMAP、POP3、SMTP)代理服务器</strong>；nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡的实现。</p></blockquote><p>(摘自<a href="https://blog.csdn.net/tsummerb/article/details/79248015" target="_blank" rel="noopener">Sugar执着的博客</a>)</p><p>解释Nginx的时候貌似又出现了新名词: 电子邮件(IMAP,POP3,SMTP)代理服务器。这个又是什么呢？</p><h4 id="IMAP-POP3-SMTP是什么？区别？"><a href="#IMAP-POP3-SMTP是什么？区别？" class="headerlink" title="IMAP,POP3,SMTP是什么？区别？"></a>IMAP,POP3,SMTP是什么？区别？</h4><p>POP3</p><blockquote><p>POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。(与IMAP有什么区别？)</p></blockquote><p>SMTP</p><blockquote><p>SMTP 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP协议的发送邮件服务器。</p><p>SMTP认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。</p><p>增加 SMTP认证的目的是为了使用户避免受到垃圾邮件的侵扰。</p></blockquote><p>IMAP</p><blockquote><p>IMAP全称是Internet Mail Access Protocol，即交互式邮件存取协议，它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。</p></blockquote><p>(摘自: <a href="http://help.163.com/09/1223/14/5R7P6CJ600753VB8.html" target="_blank" rel="noopener">163网易免费邮</a>)</p><p>总而言之，这三个东西都是邮件发送或者接收的协议。</p><h4 id="正向代理是什么？"><a href="#正向代理是什么？" class="headerlink" title="正向代理是什么？"></a>正向代理是什么？</h4><p>如今，我们要访问国外的某些网站，正常情况下无法访问，有很多人会用FQ操作去访问。FQ方式就是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，然后由代理服务器去访问国外的网站，然后将访问到的数据发送给我们。</p><p>这就是正向代理。一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定了目标。然后代理向原始服务器转交请求，并将获得的内容返回给客户端。</p><h4 id="反向代理是什么？"><a href="#反向代理是什么？" class="headerlink" title="反向代理是什么？"></a>反向代理是什么？</h4><p>反向代理是代理服务器的一种，代理服务器根据根据客户端的请求，从其关联的一组或多组后端服务器获取资源，然后再将这些资源返回给客户端。客户端只会知道代理服务器的IP地址，而不知道在代理服务器后面的服务器的存在。</p><p>如：<br>某宝网站。每天访问的人数都贼多。单个服务器无法承受如此高的访问量。这时候就出现了一个新名词：分布式部署—就是通过部署多个服务器来解决访问人数限制的问题。某宝网站就是通过Nginx进行反向代理实现的。通过封装Nginx和其他组件，<a href="http://tengine.taobao.org/" target="_blank" rel="noopener">Tengine</a>就诞生了。</p><h4 id="负载均衡是什么？"><a href="#负载均衡是什么？" class="headerlink" title="负载均衡是什么？"></a>负载均衡是什么？</h4><p>首先，我们先来了解一下负载量和均衡规则分别是什么。</p><h5 id="负载量"><a href="#负载量" class="headerlink" title="负载量"></a>负载量</h5><p>客户端发送的，Nginx反向代理服务器收到的请求数量，就是我们所说的负载量。</p><h5 id="均衡规则"><a href="#均衡规则" class="headerlink" title="均衡规则"></a>均衡规则</h5><p>请求按照一定规则进行分发到不同服务器的规则，就是均衡规则。</p><p><strong>所以，把服务器接收到的请求按照规则分发的过程，防止出现超过服务器处理能力，响应速度慢，甚至无法连接的情况，就是负载均衡。</strong></p><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><blockquote><p>-硬件负载均衡<br>如F5负载均衡，数据稳定性及安全性好，但是相对造价昂贵。</p></blockquote><blockquote><p>-软件负载均衡<br>利用现有的技术结合主机硬件实现的一种消息队列分发机制。</p></blockquote><h5 id="nginx支持的负载均衡调度算法"><a href="#nginx支持的负载均衡调度算法" class="headerlink" title="nginx支持的负载均衡调度算法"></a>nginx支持的负载均衡调度算法</h5><blockquote><p>weight轮询（默认）：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。<br>这种方式下，可以给不同的后端服务器设置一个权重值（weight），用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。</p></blockquote><blockquote><p>ip_hash(散列)：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。</p></blockquote><blockquote><p>fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块</p></blockquote><blockquote><p>url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在nginx作为静态服务器的情况下提高缓存效率。同样要注意nginx默认不支持这种调度算法，要使用的话需要安装nginx的hash软件包。</p></blockquote><p>(摘自<a href="https://blog.csdn.net/tsummerb/article/details/79248015" target="_blank" rel="noopener">Sugar执着的博客</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前没有接触过Nginx，今天偶然看到这个新名词，不自觉就去百度了一下。&lt;/p&gt;
&lt;h4 id=&quot;什么是Nginx&quot;&gt;&lt;a href=&quot;#什么是Nginx&quot; class=&quot;headerlink&quot; title=&quot;什么是Nginx?&quot;&gt;&lt;/a&gt;什么是Nginx?&lt;/h4&gt;&lt;bl
      
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Git学习笔记2</title>
    <link href="http://yoursite.com/2019/07/25/Git%E5%AD%A6%E4%B9%A02/"/>
    <id>http://yoursite.com/2019/07/25/Git学习2/</id>
    <published>2019-07-25T07:38:47.877Z</published>
    <updated>2019-07-25T07:39:46.112Z</updated>
    
    <content type="html"><![CDATA[<h3 id="十二-合并的冲突"><a href="#十二-合并的冲突" class="headerlink" title="十二. 合并的冲突"></a>十二. 合并的冲突</h3><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature1</span><br></pre></td></tr></table></figure><p>创建一个新的分支</p><p>修改，add，提交之后使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p>切换回来，</p><p>再修改，add，提交之后使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br></pre></td></tr></table></figure><p>会出现冲突</p><p>可以用git diff 文件名来查看冲突</p><p>然后，直接进文件修改，把冲突修改掉<br>就可以继续add和commit了</p><p>最后，删除feature1分支</p><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。<br>用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph</span><br></pre></td></tr></table></figure><p>命令可以看到分支合并图。</p><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息</p><p>但是–no-ff 可以禁用fast forward模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure><p>语句使用后再次使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph</span><br></pre></td></tr></table></figure><p>命令可以看到完整的分支合并图。</p><hr><h3 id="十三-分支策略"><a href="#十三-分支策略" class="headerlink" title="十三. 分支策略"></a>十三. 分支策略</h3><p>首先，master分支应该是非常稳定的，也就是仅用来发布新版本</p><p>干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</p><h4 id="代码写一半，却要先进行别的工作"><a href="#代码写一半，却要先进行别的工作" class="headerlink" title="代码写一半，却要先进行别的工作"></a>代码写一半，却要先进行别的工作</h4><p>可以先使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure><p>来把当前工作现场储藏起来,然后切换到需要修复bug的分支上,使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p>创建临时分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b issue-101</span><br></pre></td></tr></table></figure><p>修改bug add commit</p><p>修复完成后，切到master分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p>然后合并</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br></pre></td></tr></table></figure><p>然后回到刚才保存了一半的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure><p>可以使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>看到git把stash内容存在某个地方了</p><p>需要恢复可以使用命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply</span><br></pre></td></tr></table></figure><p>↑但是stash的内容并不会删除</p><p>要使用下面的命令来删除:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash drop</span><br></pre></td></tr></table></figure><p>或者一次执行两步，使用语句:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><p>可以在恢复的同时，也把stash内容也删了</p><p>可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash</p><h4 id="每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。"><a href="#每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。" class="headerlink" title="每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。"></a>每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</h4><p>例如，使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-vulcan</span><br></pre></td></tr></table></figure><p>如果要丢弃一个没有被合并过的分支，可以通过命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D &lt;name&gt;</span><br></pre></td></tr></table></figure><p>来强行删除</p><hr><h3 id="十四-多人协作"><a href="#十四-多人协作" class="headerlink" title="十四. 多人协作"></a>十四. 多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br></pre></td></tr></table></figure><p>来查看远程库的信息</p><p>用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><p>显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。</p><p>使用语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>或者直接可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br></pre></td></tr></table></figure><p>可以把该分支上的所有本地文件提交推送到远程库</p><br><blockquote><p>• master分支是主分支，因此要时刻与远程同步   </p><p>• dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；   </p><p>• bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；   </p><p>• feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p></blockquote><hr><h3 id="十五-抓取分支"><a href="#十五-抓取分支" class="headerlink" title="十五. 抓取分支"></a>十五. 抓取分支</h3><p>使用命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/learngit.git</span><br></pre></td></tr></table></figure><p>把远程仓库拷贝到本地仓库</p><p>但是本地只会看到一个master分支</p><p>使用命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>创建一个新的分支</p><p>修改完文件，add，commit之后，使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p>来把文件推送提交到远程仓库上</p><p>如果别人在你之前已经又提交过origin/dev的文件</p><p>先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：</p><p>git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：</p><p>使用命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br></pre></td></tr></table></figure><p>这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：</p><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用git push origin <branch-name>推送自己的修改；</branch-name></li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</branch-name></li></ol><p>如果git pull提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no tracking information</span><br></pre></td></tr></table></figure><p>则说明本地分支和远程分支的链接关系没有创建，用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</span><br></pre></td></tr></table></figure><p>。<br>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><p>小结</p><blockquote><p>•    查看远程库信息，使用git remote -v；</p><p>•    本地新建的分支如果不推送到远程，对其他人就是不可见的；</p><p>•    从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</p><p>•    在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p><p>•    建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p><p>•    从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p></blockquote><hr><h3 id="十六-标签管理"><a href="#十六-标签管理" class="headerlink" title="十六. 标签管理"></a>十六. 标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。</p><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">$ git checkout master</span><br></pre></td></tr></table></figure><p>然后使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><p>就可以打上标签</p><p>默认标签是打在最新的commit上的</p><p>如果要给之前的版本打标签，方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br></pre></td></tr></table></figure><p>然后</p><p>指定commit id打标签，若对应的commit id是f52c633，敲入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure><p>然后可以使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure><p>来查看标签</p><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br></pre></td></tr></table></figure><p>可以查看标签信息</p><p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure><p>然后使用命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br></pre></td></tr></table></figure><p>可以看到说明文字</p><p>删除标签<br>可以使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br></pre></td></tr></table></figure><p>如果要推送某个标签到远程，使用命令git push origin <tagname>：</tagname></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br></pre></td></tr></table></figure><hr><h3 id="十七-忽略特殊文件"><a href="#十七-忽略特殊文件" class="headerlink" title="十七. 忽略特殊文件"></a>十七. 忽略特殊文件</h3><p>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p><p>可以在这上面找各个编程软件的gitignore<br><a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p><p>编写好你的gitignore文件之后，<br>得到一个完整的.gitignore文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"># My configurations:</span><br><span class="line">db.ini</span><br><span class="line">deploy_key_rsa</span><br></pre></td></tr></table></figure><p>最后一步就是把.gitignore也提交到Git，就完成了！</p><p>想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add App.class</span><br></pre></td></tr></table></figure><p>可以使用命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f App.class</span><br></pre></td></tr></table></figure><p>强制添加到git</p><h3 id="十八-配置别名"><a href="#十八-配置别名" class="headerlink" title="十八. 配置别名"></a>十八. 配置别名</h3><p>命令: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure><p>可以将git status 简写位git st</p><p>命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.log &quot;log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure><p>可以把log目录变的好看一点</p><p>配置Git的时候，加上–global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;十二-合并的冲突&quot;&gt;&lt;a href=&quot;#十二-合并的冲突&quot; class=&quot;headerlink&quot; title=&quot;十二. 合并的冲突&quot;&gt;&lt;/a&gt;十二. 合并的冲突&lt;/h3&gt;&lt;p&gt;使用命令&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>学习路径(从上往下) by 王迎旭</title>
    <link href="http://yoursite.com/2019/07/24/studyGuide/"/>
    <id>http://yoursite.com/2019/07/24/studyGuide/</id>
    <published>2019-07-24T07:59:44.701Z</published>
    <updated>2019-07-25T07:43:26.976Z</updated>
    
    <content type="html"><![CDATA[<h4 id="所有的学习都建立在扎实的HTML-CSS-JavaScript的基础之上"><a href="#所有的学习都建立在扎实的HTML-CSS-JavaScript的基础之上" class="headerlink" title="所有的学习都建立在扎实的HTML,CSS,JavaScript的基础之上"></a>所有的学习都建立在扎实的HTML,CSS,JavaScript的基础之上</h4><p>想入手前端，我却很迷茫不知道应该按照一个怎样的路去走。经过不断地查阅网上的资料以及实习时问周边的大佬。因此，我总结出了以下的学习路径。现在才大二，还有很长的一段路要走。</p><p><strong>1.html5</strong></p><blockquote><p>-w3cschool</p></blockquote><p><strong>2.css3</strong></p><blockquote><p>-《精通CSS》</p></blockquote><p><strong>3.javaScript</strong></p><blockquote><p>-《javaScript高级程序设计第3版》   </p><p>-《javaScript DOM编程艺术第2版》</p></blockquote><p>重点: 闭包，原型链，this，DOM编程, Ajax等</p><p><strong>4.ES6</strong></p><blockquote><p>-《ES6标准入门》</p></blockquote><p>重点: Promise, 箭头函数, Async/Await等</p><p><strong>5.Node</strong></p><blockquote><p>-《Node.js开发指南》</p><p>-《深入浅出Node.js》</p><p>-CNode社区</p></blockquote><p><strong>6.工程类工具</strong></p><blockquote><p>(1) 项目构建，打包，压缩: Webpack   </p></blockquote><blockquote><p>(2) 编译(将ES2015+转化为ES2015): Babel   </p></blockquote><blockquote><p>(3) 版本管理: Git(推荐，我是先学这个), SVN(较为落后)</p></blockquote><p><strong>7.框架</strong></p><blockquote><p>(1) 操作DOM: jQuery, zepto   </p><p>(2) 操作数据: Vue, React, Angular</p></blockquote><p>重点: 设计思想，Diff算法，相关生态等</p><p><strong>8.数据结构和算法(尽早学，培养思想)</strong></p><blockquote><p>极客时间-王争专栏</p></blockquote><p><strong>9.性能优化</strong></p><blockquote><p>-《高性能javaScript》</p></blockquote><p>注意: 第五章，v8已经做优化；第九章，构建部分，现在基于webpack已经有很成熟的方案了；第十章工具不用看，直接去看chrome的devtool文档</p><p><strong>10.网络编程</strong>   </p><p>关键字:</p><blockquote><p>-fetch</p><p>-websocket</p><p>-jsonp</p><p>-cors</p><p>-formData</p><p>-Fetch api</p><p>-Ajax</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;所有的学习都建立在扎实的HTML-CSS-JavaScript的基础之上&quot;&gt;&lt;a href=&quot;#所有的学习都建立在扎实的HTML-CSS-JavaScript的基础之上&quot; class=&quot;headerlink&quot; title=&quot;所有的学习都建立在扎实的HTML,CSS
      
    
    </summary>
    
      <category term="StudyGuide" scheme="http://yoursite.com/categories/StudyGuide/"/>
    
    
  </entry>
  
  <entry>
    <title>服务端渲染 vs 客户端渲染</title>
    <link href="http://yoursite.com/2019/07/24/SSR&amp;CSR/"/>
    <id>http://yoursite.com/2019/07/24/SSR&amp;CSR/</id>
    <published>2019-07-24T06:17:11.696Z</published>
    <updated>2019-07-24T06:27:55.254Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到了两个新概念: 服务端渲染(SSR)和客户端渲染(CSR)。他们分别是什么，各自有什么区别呢？</p><h3 id="服务端渲染-SSR-Server-Side-Render"><a href="#服务端渲染-SSR-Server-Side-Render" class="headerlink" title="服务端渲染(SSR: Server Side Render)"></a>服务端渲染(SSR: Server Side Render)</h3><p>概念: <strong>服务器端</strong>生成html字符串，在给客户端返回html前，先在指定区域内填充数据和符号，再发送给客户端。<strong>客户端只负责解析html</strong></p><blockquote><p>优点: </p><ol><li>前端耗时少，因为不再依赖与js文件首屏渲染快，客户端只用解析html</li><li>有利于SEO(Search Engine Optimization)搜索引擎优化，因为数据在服务器端上显示都是渲染完成的</li></ol></blockquote><br> <blockquote><p>缺点:</p><ol><li>服务器端性能消耗较大，用户体验差</li><li>不容易维护，前端修改html和css后端也需要修改</li></ol></blockquote><hr><h3 id="客户端渲染-CSR-Client-Side-Render"><a href="#客户端渲染-CSR-Client-Side-Render" class="headerlink" title="客户端渲染(CSR: Client Side Render)"></a>客户端渲染(CSR: Client Side Render)</h3><p>概念: html作为静态文件，客户端在请求的时候，服务端不做任何处理，直接以源文件的形式返回给客户端，然后根据html上的JavaScript，生成DOM插入html(摘自:<a href="https://www.jianshu.com/p/656a1666a1c5?utm_source=oschina-app" target="_blank" rel="noopener">、三毛的简书</a>)</p><blockquote><p>优点: </p><ol><li>减少了服务器端的压力   </li><li>可以实现局部刷新，无需每次都请求完整的页面</li></ol></blockquote><br><blockquote><p>缺点: </p><ol><li>前端耗时多，渲染慢   </li><li>使用了React或者其他MVVM框架之后，因为页面的DOM元素都是在客户端根据js动态生成，网络上的爬虫不会等待数据加载完成之后再爬去数据，因此可供爬虫抓取分析的内容减少。不利于SEO</li></ol></blockquote><hr><p>所以，现在很多公司的网站都是SSR和CSR混着用，比如京东的商品列表用的是服务端渲染，目的是为了优化SEO，而京东的商品评论列表用的是客户端渲染，优化了用户体验</p><hr><h3 id="如何判断一个页面是服务器端渲染还是客户端渲染呢？"><a href="#如何判断一个页面是服务器端渲染还是客户端渲染呢？" class="headerlink" title="如何判断一个页面是服务器端渲染还是客户端渲染呢？"></a>如何判断一个页面是服务器端渲染还是客户端渲染呢？</h3><p>打开一个网页，右键点击查看网页源代码，如果页面上有的东西在源代码里面也可以看得到，则是服务端渲染；反之，如果右键查看网页源代码看不到，那么便是在客户端渲染的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天遇到了两个新概念: 服务端渲染(SSR)和客户端渲染(CSR)。他们分别是什么，各自有什么区别呢？&lt;/p&gt;
&lt;h3 id=&quot;服务端渲染-SSR-Server-Side-Render&quot;&gt;&lt;a href=&quot;#服务端渲染-SSR-Server-Side-Render&quot; cla
      
    
    </summary>
    
      <category term="Web" scheme="http://yoursite.com/categories/Web/"/>
    
    
  </entry>
  
  <entry>
    <title>Git学习笔记1</title>
    <link href="http://yoursite.com/2019/07/24/GitLearn1/"/>
    <id>http://yoursite.com/2019/07/24/GitLearn1/</id>
    <published>2019-07-24T02:06:33.801Z</published>
    <updated>2019-07-24T06:27:48.557Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容均来自于<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰老师的Git教程</a>，是我学习的过程中加以理解和简化做下的笔记，以便日后查找和翻阅</p></blockquote><h3 id="一-介绍"><a href="#一-介绍" class="headerlink" title="一. 介绍"></a>一. 介绍</h3><ol><li><p>Git是一个版本控制工具，能实现多个成员同时共同管理开发一个或多个文档的工具。</p></li><li><p>Git是一个<strong>分布式版本控制系统</strong>，不同于CVS以及SVN等集中式版本控制系统</p></li></ol><h4 id="什么是集中式版本控制系统？"><a href="#什么是集中式版本控制系统？" class="headerlink" title="什么是集中式版本控制系统？"></a>什么是集中式版本控制系统？</h4><ol><li>版本库集中存放在中央服务器，每个人需要用到文件时从中央服务器取得最新的版本，然后修改完毕后再将文件传回给中央服务器。</li><li>需要联网</li></ol><h4 id="什么是分布式版本控制系统？"><a href="#什么是分布式版本控制系统？" class="headerlink" title="什么是分布式版本控制系统？"></a>什么是分布式版本控制系统？</h4><p>每个人的电脑上都有一个完整的版本库，工作时无需联网，可相互传文件，看到各自的修改。</p><hr><h3 id="二-安装"><a href="#二-安装" class="headerlink" title="二. 安装"></a>二. 安装</h3><ol><li>上官网下载安装</li><li>安装完成后，在桌面 Git Bash here</li><li>输入命令:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><p>git config命令的–<strong>global参数</strong>，<br>用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><hr><h3 id="三-创建版本库"><a href="#三-创建版本库" class="headerlink" title="三. 创建版本库"></a>三. 创建版本库</h3><p>版本库又叫仓库(Repository), 里面的所有文件都可以被Git所管理，每个文件的修改，删除都能被跟踪，也可以还原。</p><p>选择一个合适的地方，我选择用 c:/git文件夹<br>分别输入以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br></pre></td></tr></table></figure><p>其中，pwd命令用于显示当前目录</p><br><p>然后再使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>把这个目录变成Git可管理的仓库</p><p>那么空仓库就建好了，<br>这个文件夹中会自动生成一个隐藏的.git的目录，这个目录是Git来跟踪管理版本库的，没事不要去手动修改这个目录里面的文件。</p><br>使用命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -ah</span><br></pre></td></tr></table></figure><p>可以看见这个隐藏的目录</p><hr><h3 id="三-注意事项"><a href="#三-注意事项" class="headerlink" title="三. 注意事项"></a>三. 注意事项</h3><p>1.所有的版本控制系统，只能跟踪纯文本文件的改动，无法跟踪视频，图片或者word文件的改动。</p><p>2.建议使用标准的UTF-8编码。</p><p>3.不要使用记事本保存文件，因为开发团队在每个文件开头都添加了0xefbbbf的字符，导致可能一编译就莫名其妙报错。可使用Notepad++来代替</p><hr><h3 id="四-添加文件到仓库"><a href="#四-添加文件到仓库" class="headerlink" title="四. 添加文件到仓库"></a>四. 添加文件到仓库</h3><p>步骤:</p><ol><li>把文件放到仓库目录下面</li><li>使用命令:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>再使用命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span><br></pre></td></tr></table></figure><p>前者为提交的文件，后者为提交的说明</p><p>可以先分别add多个文件后提交一个说明,例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="五-查看修改状态"><a href="#五-查看修改状态" class="headerlink" title="五. 查看修改状态"></a>五. 查看修改状态</h3><p>输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p>可以查看所有仓库里面的文件的修改状态，如，modified</p><p>输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt</span><br></pre></td></tr></table></figure><p>可以查看具体的修改情况<br>如下   </p><blockquote><p>-Git is a version control system.   </p><p>+Git is a distributed version control system.   </p><p> Git is free software   </p><p>\ No newline at end of file</p></blockquote><p>小结   </p><p>•    要随时掌握工作区的状态，使用git status命令。   </p><p>•    如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</p><hr><h3 id="六-版本回退"><a href="#六-版本回退" class="headerlink" title="六. 版本回退"></a>六. 版本回退</h3><p>$ ++git add++ 和 $ ++git commit++的操作就像是存档，就算数据丢失或者任何意外情况发生，只要你电脑还在，就可以恢复到之前的情况。</p><p>输入命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure><p>可以查看所有提交的历史纪录</p><br>而<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br></pre></td></tr></table></figure><p>则可以更美观一些</p><p>会输出</p><blockquote><p>8b7f70a69ec9b385e04204fbd968048e264280d8 (HEAD -&gt; master) add distributed   </p><p>0676cc984f57df152f2d2d886cd1e4caa13132ca wrote a readme file</p></blockquote><p>前面遗传乱码都是commit id(版本号), 在SVN中为1，2，3…<br>是一个用SHA加密方式计算出来的一个非常大的数字<br>上往下的是从新到旧的版本<br><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset</span><br></pre></td></tr></table></figure><p>命令可以让版本回退   </p><p>HEAD^为回到上个版本   </p><p>HEAD^^为上上个版本</p><p>HEAD^100为上100个版本   </p><p>以此类推…</p><hr><p>所以使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>就会回到上一个版本</p><p>一旦有误删的情况，<br>只要命令行还没关掉，就还能回到刚刚那个版本<br>往上找版本号<br>输入命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br></pre></td></tr></table></figure><p>1094a为版本号的前5位</p><p>但是如果命令行关掉了</p><p>还是能使用命令<br>git reflog<br>来回到之前的版本的</p><hr><h3 id="七-工作区和暂存区"><a href="#七-工作区和暂存区" class="headerlink" title="七. 工作区和暂存区"></a>七. 工作区和暂存区</h3><ol><li>工作区就是电脑里面能看到的目录，如刚刚创建的learngit</li><li>工作区里面的隐藏目录.git不是工作区，而是git的版本库</li></ol><blockquote><p>Git的版本库里面有一个称为stage的暂存区，以及Git自动创建的第一个分支master和指向master的指针HEAD</p></blockquote><p><strong>Git add指令</strong>其实是把文件修改添加到暂存区   </p><p><strong>Git commit指令</strong>是把暂存区的所有内容提交到当前分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt</span><br></pre></td></tr></table></figure><p> 命令可以查看工作区和master分支里面的文件内容区别</p><p>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure><p>可以把readme.txt文件在工作区的修改全部撤销</p><blockquote><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p></blockquote><p>==慎用此命令，因为会重写工作区！==</p><p>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p><p>已经添加到暂存区的文件，还未提交，可以用命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br></pre></td></tr></table></figure><p>来撤回到工作区<br><br></p><p>然后再用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Git checkout -- reset readme.txt</span><br></pre></td></tr></table></figure><p>来将工作区的改动恢复到原来的状态</p><p>小结   </p><blockquote><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。   </p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。   </file></p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库</p></blockquote><p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h3 id="八-在github上绑定ssh"><a href="#八-在github上绑定ssh" class="headerlink" title="八. 在github上绑定ssh"></a>八. 在github上绑定ssh</h3><h3 id="九-在github上创建新的仓库"><a href="#九-在github上创建新的仓库" class="headerlink" title="九. 在github上创建新的仓库"></a>九. 在github上创建新的仓库</h3><p>使用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:WangyingxuHalo/learngit.git</span><br></pre></td></tr></table></figure><p>来关联远程库</p><p>添加后，远程库的名字就是origin，这是Git默认的叫法</p><p>下一步，就可以把本地库(即master分支)的所有内容推送到远程库上:   </p><p>使用命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p>-u指令指的是：不仅把版本库的内容提交，而且关联</p><p>只有第一次需要。以后就不用再输入-u指令了</p><p>以后，只要本地作了提交，就可以通过命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>来同步到github上</p><hr><h3 id="十-将远程仓库同步到本地仓库"><a href="#十-将远程仓库同步到本地仓库" class="headerlink" title="十. 将远程仓库同步到本地仓库"></a>十. 将远程仓库同步到本地仓库</h3><p>输入命令: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:WangyingxuHalo/GitTry.git</span><br></pre></td></tr></table></figure><p>Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快</p><hr><h3 id="十一-分支和合并"><a href="#十一-分支和合并" class="headerlink" title="十一. 分支和合并"></a>十一. 分支和合并</h3><p>创建dev分支，然后切换到dev分支</p><p>命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br></pre></td></tr></table></figure><p>git checkout命令加上-<strong>b</strong>参数表示创建并切换，相当于以下两条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure><p>git branch dev为创建名为dev的分支   </p><p>git checkout dev为切换到名为dev的分支</p><p>然后我们可以用命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure><p>来查看当前的分支</p><p>然后之后的操作就都是在dev这个branch上进行的了</p><p>可以进行git add 和 git commit</p><p>现在，dev分支的工作完成，我们就可以切换回master分支：</p><p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：</p><p>然后使用命令把dev分支的工作成果合并到master分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br></pre></td></tr></table></figure><p><strong>git merge</strong>命令用于合并指定分支到当前分支。</p><p>合并完成后，就可以放心地删除dev分支了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure><p>小结   </p><blockquote><p>Git鼓励大量使用分支：   </p><p>查看分支：git branch   </p><p>创建分支：git branch <name>   </name></p><p>切换分支：git checkout <name>   </name></p><p>创建+切换分支：git checkout -b <name>   </name></p><p>合并某分支到当前分支：git merge <name>   </name></p><p>删除分支：git branch -d <name></name></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以下内容均来自于&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;廖雪峰老师的Git教程&lt;/a&gt;，是我学习的过程中加以
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>js之获取浏览器语言</title>
    <link href="http://yoursite.com/2019/07/22/navigatorLanguage/"/>
    <id>http://yoursite.com/2019/07/22/navigatorLanguage/</id>
    <published>2019-07-22T08:55:58.064Z</published>
    <updated>2019-07-23T02:15:43.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="navigator-language和navigator-browserLanguage"><a href="#navigator-language和navigator-browserLanguage" class="headerlink" title="navigator.language和navigator.browserLanguage"></a>navigator.language和navigator.browserLanguage</h1><p>&#8195;&#8195;今天看代码的时候看到了navigator.language以及navigator.browserLanguage<br><br>那这些分别指代的是哪里的语言呢？<br>我百度了一下<br><br>W3C文档上写着：<br><br><strong>window.navigator.language<br>Returns a language tag representing the user’s preferred language.</strong><br></p><h2 id="什么意思呢？"><a href="#什么意思呢？" class="headerlink" title="什么意思呢？"></a>什么意思呢？</h2><p>也就是说，每个浏览器会有一个语言列表的设置，用户可以设置自己的首选语言，那么window.navigator.language<br>就会返回浏览器中用户的首选语言</p><p>例如我在chrome浏览器中使用以下语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(window.navigator.language)</span><br></pre></td></tr></table></figure><p>会输出 ‘zh-CN’</p><p>而将首选语言改为英文之后会输出 ‘en’</p><hr><p>navigator.browserLanguage和前面的类似，<br><br>不过各种浏览器有不同的兼容<br><br>看见一篇博客<br>如下</p><table><thead><tr><th align="left"></th><th align="center">IE6 IE7 IE8</th><th align="center">Firefox Safari Chrome</th><th align="right">Opera</th></tr></thead><tbody><tr><td align="left">navigator.language</td><td align="center">undefined</td><td align="center">zh-CN</td><td align="right">zh-CN</td></tr><tr><td align="left">navigator.userLanguage</td><td align="center">zh-cn</td><td align="center">undefined</td><td align="right">zh-cn</td></tr><tr><td align="left">navigator.browserLanguage</td><td align="center">zh-cn</td><td align="center">undefined</td><td align="right">zh-cn</td></tr><tr><td align="left">navigator.systemLanguage</td><td align="center">zh-cn</td><td align="center">undefined</td><td align="right">undefined</td></tr></tbody></table><p>图片来源:</p><blockquote><p><a href="https://blog.csdn.net/lvjin110/article/details/37663067" target="_blank" rel="noopener">https://blog.csdn.net/lvjin110/article/details/37663067</a></p></blockquote><p>但是我自己尝试的时候IE浏览器也会打印 ‘zh-CN’<br>可能这个版本比较老，现在IE浏览器版本高了很多吧</p><p>为了适配所有浏览器，书写代码的时候可以这么写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const browserLang = navigator.language || navigator.browserLanguage || &apos;zh&apos;</span><br></pre></td></tr></table></figure><p>意思是：<br><br>如果navigator.language的值为undefined，则使用navigator.browserLanguage，如果navigator.browserLanguage的值为undefined，则取’zh’</p><p>因为可能有大小写的区别，根据写法和判断的不同，也可以写成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(navigator.language || navigator.browserLanguage).toLowerCase()</span><br></pre></td></tr></table></figure><p>这样基本就能考虑到所有浏览器的兼容性了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;navigator-language和navigator-browserLanguage&quot;&gt;&lt;a href=&quot;#navigator-language和navigator-browserLanguage&quot; class=&quot;headerlink&quot; title=&quot;navi
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
  </entry>
  
</feed>
